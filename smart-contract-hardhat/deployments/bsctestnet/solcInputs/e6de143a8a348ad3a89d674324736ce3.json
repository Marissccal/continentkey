{
  "language": "Solidity",
  "sources": {
    "solidity/contracts/FirstPresale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n// Imports\nimport \"./Libraries.sol\";\n\ncontract FirstPresale is ReentrancyGuard {\n    address public owner; // Dueño del contrato.\n    IERC20 public token; // MYM Token.\n    bool private tokenAvailable = false;\n    uint public tokensPerBNB = 8000; // Cantidad de MYMs que se van a repartir por cada BNB aportado.\n    uint public ending; // Tiempo que va finalizar la preventa.\n    bool public presaleStarted = false; // Indica si la preventa ha sido iniciada o no.\n    address public deadWallet = 0x000000000000000000000000000000000000dEaD; // Wallet de quemado.\n    uint public cooldownTime = 30 minutes;\n    uint public tokensSold;\n\n    mapping(address => bool) public whitelist; // Whitelist de inversores permitidos en la preventa.\n    mapping(address => uint) public invested; // Cantidad de BNBs que ha invertido cada inversor en la preventa.\n    mapping(address => uint) public investorBalance;\n    mapping(address => uint) public withdrawableBalance;\n    mapping(address => uint) public claimReady;\n\n    constructor(address _teamWallet) {\n        owner = _teamWallet;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, 'You must be the owner.');\n        _;\n    }\n\n    /**\n     * @notice Función que actualiza el token en el contrato (Solo se puede hacer 1 vez).\n     * @param _token Dirección del contrato del token.\n     */\n    function setToken(IERC20 _token) public onlyOwner {\n        require(!tokenAvailable, \"Token is already inserted.\");\n        token = _token;\n        tokenAvailable = true;\n    }\n\n    /**\n     * @notice Función que permite añadir inversores a la whitelist.\n     * @param _investor Direcciones de los inversores que entran en la whitelist.\n     */\n    function addToWhitelist(address[] memory _investor) public onlyOwner {\n        for (uint _i = 0; _i < _investor.length; _i++) {\n            require(_investor[_i] != address(0), 'Invalid address.');\n            address _investorAddress = _investor[_i];\n            whitelist[_investorAddress] = true;\n        }\n    }\n\n    /**\n     * @notice Función que inicia la Preventa (Solo se puede iniciar una vez).\n     * @param _presaleTime Tiempo que va a durar la preventa.\n     */\n    function startPresale(uint _presaleTime) public onlyOwner {\n        require(!presaleStarted, \"Presale already started.\");\n\n        ending = block.timestamp + _presaleTime;\n        presaleStarted = true;\n    }\n\n    /**\n     * @notice Función que te permite comprar MYMs. \n     */\n    function invest() public payable nonReentrant {\n        require(whitelist[msg.sender], \"You must be on the whitelist.\");\n        require(presaleStarted, \"Presale must have started.\");\n        require(block.timestamp <= ending, \"Presale finished.\");\n        invested[msg.sender] += msg.value; // Actualiza la inversión del inversor.\n        require(invested[msg.sender] >= 0.10 ether, \"Your investment should be more than 0.10 BNB.\");\n        require(invested[msg.sender] <= 10 ether, \"Your investment cannot exceed 10 BNB.\");\n\n        uint _investorTokens = msg.value * tokensPerBNB; // Tokens que va a recibir el inversor.\n        investorBalance[msg.sender] += _investorTokens;\n        withdrawableBalance[msg.sender] += _investorTokens;\n        tokensSold += _investorTokens;\n    }\n\n    /**\n     * @notice Calcula el % de un número.\n     * @param x Número.\n     * @param y % del número.\n     * @param scale División.\n     */\n    function mulScale (uint x, uint y, uint128 scale) internal pure returns (uint) {\n        uint a = x / scale;\n        uint b = x % scale;\n        uint c = y / scale;\n        uint d = y % scale;\n\n        return a * c * scale + a * d + b * c + b * d / scale;\n    }\n\n    /**\n     * @notice Función que permite a los inversores hacer claim de sus tokens disponibles.\n     */\n    function claimTokens() public nonReentrant {\n        require(whitelist[msg.sender], \"You must be on the whitelist.\");\n        require(block.timestamp > ending, \"Presale must have finished.\");\n        require(claimReady[msg.sender] <= block.timestamp, \"You can't claim now.\");\n        uint _contractBalance = token.balanceOf(address(this));\n        require(_contractBalance > 0, \"Insufficient contract balance.\");\n        require(investorBalance[msg.sender] > 0, \"Insufficient investor balance.\");\n\n        uint _withdrawableTokensBalance = mulScale(investorBalance[msg.sender], 2500, 10000); // 2500 basis points = 25%.\n\n        // Si tu balance es menor a la cantidad que puedes retirar directamente te transfiere todo tu saldo.\n        if(withdrawableBalance[msg.sender] <= _withdrawableTokensBalance) {\n            token.transfer(msg.sender, withdrawableBalance[msg.sender]);\n\n            investorBalance[msg.sender] = 0;\n            withdrawableBalance[msg.sender] = 0;\n        } else {\n            claimReady[msg.sender] = block.timestamp + cooldownTime; // Actualiza cuando será el próximo claim.\n\n            withdrawableBalance[msg.sender] -= _withdrawableTokensBalance; // Actualiza el balance del inversor.\n\n            token.transfer(msg.sender, _withdrawableTokensBalance); // Transfiere los tokens.\n        }\n    }\n\n    /**\n     * @notice Función que permite retirar los BNBs del contrato a la dirección del owner.\n     */\n    function withdrawBnbs() public onlyOwner {\n        uint _bnbBalance = address(this).balance;\n        payable(owner).transfer(_bnbBalance);\n    }\n\n    /**\n     * @notice Función que quema los tokens que sobran en la preventa.\n     */\n    function burnTokens() public onlyOwner {\n        require(block.timestamp > ending, \"Presale must have finished.\");\n        \n        uint _contractBalance = token.balanceOf(address(this));\n        uint _tokenBalance = _contractBalance - tokensSold;\n        token.transfer(deadWallet, _tokenBalance);\n    }\n}"
    },
    "solidity/contracts/Libraries.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\ninterface IPancakeFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n\ninterface IUniswapV2Router02 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n\ninterface IERC20 {\n    function decimals() external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}"
    },
    "solidity/contracts/TeamVesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n// Imports\nimport \"./Libraries.sol\";\n\ncontract TeamVesting is ReentrancyGuard {\n    IERC20 public token;\n    address public teamWallet; // Wallet del equipo.\n    uint public cooldownTime = 30 minutes; // Tiempo de cooldown que va a tener el claim.\n    uint public claimReady; // Guarda el tiempo en el que el usuario podrá hacer el próximo claim.\n    bool private tokenAvailable = false;\n\n    constructor(address _teamWallet) {\n        teamWallet = _teamWallet;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == teamWallet, 'You must be the owner.');\n        _;\n    }\n\n    /**\n     * @notice Función que actualiza el token en el contrato (Solo se puede hacer 1 vez).\n     * @param _token Dirección del contrato del token.\n     */\n    function setToken(IERC20 _token) public onlyOwner {\n        require(!tokenAvailable, \"Token is already inserted.\");\n        token = _token;\n        tokenAvailable = true;\n    }\n\n    /**\n     * @notice Calcula el % de un número.\n     * @param x Número.\n     * @param y % del número.\n     * @param scale División.\n     */\n    function mulScale (uint x, uint y, uint128 scale) internal pure returns (uint) {\n        uint a = x / scale;\n        uint b = x % scale;\n        uint c = y / scale;\n        uint d = y % scale;\n\n        return a * c * scale + a * d + b * c + b * d / scale;\n    }\n\n    /**\n     * @notice Función que permite hacer claim de los tokens que se pueden claimear (8,33% cada mes).\n     */\n    function claimTokens() public onlyOwner nonReentrant {\n        require(claimReady <= block.timestamp, \"You can't claim now.\");\n        uint _contractBalance = token.balanceOf(address(this));\n        require(_contractBalance > 0, \"Insufficient Balance.\");\n\n        uint _withdrawableBalance = mulScale(_contractBalance, 833, 10000); // 833 basis points = 8,33%.\n\n        if(_contractBalance <= _withdrawableBalance) {\n            token.transfer(teamWallet, _contractBalance);\n        } else {\n            claimReady = block.timestamp + cooldownTime;\n\n            token.transfer(teamWallet, _withdrawableBalance); \n        }\n    }\n}"
    },
    "solidity/contracts/Tazerling.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"./Libraries.sol\";\n\ncontract TazerlingSwap {\n    string public name = \"TazerlingSwap\";\n    string public symbol = \"TazerlingSwap\";\n    uint256 public totalSupply = 300000000000000000000000000; // 300 millones de tokens\n    uint8 public decimals = 18;\n    address public teamWallet; // Dueño del contrato.\n    address public marketingWallet; // Dirección de la billetera de marketing.\n    address private firstPresaleContract; // Dirección del contrato de la primera preventa.\n    address private teamVestingContract; // Dirección del contrato de vesting para el equipo.\n    IUniswapV2Router02 router; // Router.\n    address private pancakePairAddress; // Dirección del par.\n    uint public liquidityLockTime = 365 days; // Tiempo que va a estar bloqueada la liquidez.\n    uint public liquidityLockCooldown;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    constructor(address _teamWallet, address _marketingWallet, address _firstPresaleContract,address _teamVestingContract) {\n        teamWallet = _teamWallet;\n        marketingWallet = _marketingWallet;\n        firstPresaleContract = _firstPresaleContract;        \n        teamVestingContract = _teamVestingContract;\n        router = IUniswapV2Router02(0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3); // Testnet // TODO: Cambiar a MainNet\n        pancakePairAddress = IPancakeFactory(router.factory()).createPair(address(this), router.WETH());\n\n        uint _firstPresaleTokens = 30000000000000000000000000;        \n        uint _teamVestingTokens = 45000000000000000000000000;\n        uint _marketingTokens = 15000000000000000000000000;\n        uint _contractTokens = totalSupply - (_teamVestingTokens + _marketingTokens + _firstPresaleTokens);\n\n        balanceOf[firstPresaleContract] = _firstPresaleTokens;        \n        balanceOf[teamVestingContract] = _teamVestingTokens;\n        balanceOf[marketingWallet] = _marketingTokens;\n        balanceOf[address(this)] = _contractTokens;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == teamWallet, 'You must be the owner.');\n        _;\n    }\n\n    /**\n     * @notice Función que permite hacer una transferencia.\n     * @param _to Dirección del destinatario.\n     * @param _value Cantidad de tokens a transferir.\n     */\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n\n        emit Transfer(msg.sender, _to, _value);\n\n        return true;\n    }\n\n    /**\n     * @notice Función que permite ver cuanta cantidad de tokens tiene permiso para gastar una dirección.\n     * @param _owner Dirección de la persona que da permiso a gastar sus tokens.\n     * @param _spender Dirección a la que se le da permiso para gastar los tokens.\n     */\n    function allowance(address _owner, address _spender) public view virtual returns (uint256) {\n        return _allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Función que incrementa el allowance.\n     * @param _spender Dirección a la que se le da permiso para gastar tokens.\n     * @param _addedValue Cantidad de tokens que das permiso para que gasten.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) public virtual returns (bool) {\n        _approve(msg.sender, _spender, _allowances[msg.sender][_spender] + _addedValue);\n\n        return true;\n    }\n\n    /**\n     * @notice Función que disminuye el allowance.\n     * @param _spender Dirección a la que se le quita permiso para gastar tokens.\n     * @param _subtractedValue Cantidad de tokens que se van a disminuir de la cantidad permitida para gastar.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, \"ERC20: decreased allowance below zero\");\n\n        unchecked {\n            _approve(msg.sender, _spender, currentAllowance - _subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Función que llama a la función interna _approve.\n     * @param _spender Dirección de la cuenta a la que le das permiso para gastar tus tokens.\n     * @param _value Cantidad de tokens que das permiso para que gasten.\n     */\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        _approve(msg.sender, _spender, _value);\n\n        return true;\n    }\n\n    /**\n     * @notice Función interna que permite aprobar a otra cuenta a gastar tus tokens.\n     * @param _owner Dirección de la cuenta que da permiso para gastar sus tokens.\n     * @param _spender Dirección de la cuenta a la que le das permiso para gastar tus tokens.\n     * @param _amount Cantidad de tokens que das permiso para que gasten.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal virtual {\n        require(_owner != address(0), \"ERC20: approve from the zero address\");\n        require(_spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[_owner][_spender] = _amount;\n\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @notice Función que permite hacer una transferencia desde una dirección.\n     * @param _from Dirección del emisor.\n     * @param _to Dirección del destinatario.\n     * @param _value Cantidad de tokens a transferir.\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= balanceOf[_from]);\n        require(_value <= _allowances[_from][msg.sender]);\n\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        _allowances[_from][msg.sender] -= _value;\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    /**\n     * @notice Función pública que permite quemar tokens.\n     * @param _amount Cantidad de tokens que se van a quemar.\n     */\n    function burn(uint256 _amount) public virtual {\n        _burn(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Función interna que permite quemar tokens.\n     * @param _account Dirección desde la que se van a quemar los tokens.\n     * @param _amount Cantidad de tokens que se van a quemar.\n     */\n    function _burn(address _account, uint256 _amount) internal virtual {\n        require(_account != address(0), 'No puede ser la direccion cero.');\n        require(balanceOf[_account] >= _amount, 'La cuenta debe tener los tokens suficientes.');\n\n        balanceOf[_account] -= _amount;\n        totalSupply -= _amount;\n\n        emit Transfer(_account, address(0), _amount);\n    }\n    \n    /**\n     * @notice Función que permite añadir liquidez.\n     * @param _tokenAmount Cantidad de tokens que se van a destinar para la liquidez.\n     */\n    function addLiquidity(uint _tokenAmount) public payable onlyOwner {\n        require(_tokenAmount > 0 || msg.value > 0, \"Insufficient tokens or BNBs.\");\n        require(IERC20(pancakePairAddress).totalSupply() == 0);\n\n        _approve(address(this), address(router), _tokenAmount);\n\n        liquidityLockCooldown = block.timestamp + liquidityLockTime;\n\n        router.addLiquidityETH{value: msg.value}(\n            address(this),\n            _tokenAmount,\n            0,\n            0,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Función que permite retirar la liquidez.\n     */\n    function removeLiquidity() public onlyOwner {\n        require(block.timestamp >= liquidityLockCooldown, \"Locked\");\n\n        IERC20 liquidityTokens = IERC20(pancakePairAddress);\n        uint _amount = liquidityTokens.balanceOf(address(this));\n        liquidityTokens.approve(address(router), _amount);\n\n        router.removeLiquidityETH(\n            address(this),\n            _amount,\n            0,\n            0,\n            teamWallet,\n            block.timestamp\n        );\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}